<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Segment Tree Crowns in a 3D Point Cloud</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for segment_tree_crowns {crownsegmentr}"><tr><td>segment_tree_crowns {crownsegmentr}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Segment Tree Crowns in a 3D Point Cloud</h2>

<h3>Description</h3>

<p>Employs a variant of the mean shift algorithm (Ferraz et. al, 2016) and after
that the DBSCAN algorithm in order to identify tree crowns in airborne lidar
data.
</p>


<h3>Usage</h3>

<pre>
segment_tree_crowns(
  point_cloud,
  crown_diameter_to_tree_height,
  crown_height_to_tree_height,
  segment_crowns_only_above = 0,
  ground_height = NULL,
  crown_id_column_name = "crown_id",
  centroid_convergence_distance = 0.01,
  max_num_centroids_per_mode = 500,
  dbscan_neighborhood_radius = 0.3,
  min_num_modes_per_neighborhood = 5,
  ...
)

## S4 method for signature 'data.frame'
segment_tree_crowns(
  point_cloud,
  crown_diameter_to_tree_height,
  crown_height_to_tree_height,
  segment_crowns_only_above,
  ground_height,
  crown_id_column_name,
  centroid_convergence_distance,
  max_num_centroids_per_mode,
  dbscan_neighborhood_radius,
  min_num_modes_per_neighborhood,
  verbose = TRUE,
  also_return_modes = FALSE,
  also_return_centroids = FALSE
)

## S4 method for signature 'LAS'
segment_tree_crowns(
  point_cloud,
  crown_diameter_to_tree_height,
  crown_height_to_tree_height,
  segment_crowns_only_above,
  ground_height,
  crown_id_column_name,
  centroid_convergence_distance,
  max_num_centroids_per_mode,
  dbscan_neighborhood_radius,
  min_num_modes_per_neighborhood,
  verbose = TRUE,
  also_return_modes = FALSE,
  also_return_centroids = FALSE,
  write_crown_id_also_to_file = FALSE,
  crown_id_file_description = crown_id_column_name
)

## S4 method for signature 'LAScatalog'
segment_tree_crowns(
  point_cloud,
  crown_diameter_to_tree_height,
  crown_height_to_tree_height,
  segment_crowns_only_above,
  ground_height,
  crown_id_column_name,
  centroid_convergence_distance,
  max_num_centroids_per_mode,
  dbscan_neighborhood_radius,
  min_num_modes_per_neighborhood,
  write_crown_id_also_to_file = TRUE,
  crown_id_file_description = crown_id_column_name
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>point_cloud</code></td>
<td>
<p>A data set containing xyz-coordinates. Can be passed as
either a <code><a href="../../base/html/data.frame.html">data.frame</a></code>, a
<code><a href="../../data.table/html/data.table.html">data.table</a></code>, or a lidR- <code><a href="../../lidR/html/LAS.html">LAS</a></code> or
<code><a href="../../lidR/html/LAScatalog-class.html">LAScatalog-class</a></code> object.
</p>
<p>If it's a <code><a href="../../base/html/data.frame.html">data.frame</a></code> or a
<code><a href="../../data.table/html/data.table.html">data.table</a></code> the function searches for coordinate
columns by looking for the first numeric columns named &quot;x&quot;/&quot;X&quot;, &quot;y&quot;/&quot;Y&quot;, or
&quot;z&quot;/&quot;Z&quot;. For each instance where it can't find one of those it selects the
next available numeric column in the table and issues a warning.</p>
</td></tr>
<tr valign="top"><td><code>crown_diameter_to_tree_height, crown_height_to_tree_height</code></td>
<td>
<p>Single
numbers or <code><a href="../../raster/html/raster.html">raster</a></code> objects covering the area of the
<code>point_cloud</code>. The values should be approximate crown diameter and
crown height to tree height ratios of the trees expected to be found in the
point cloud. Points will not be segmented wherever a raster contains
<code>NA</code> values.</p>
</td></tr>
<tr valign="top"><td><code>segment_crowns_only_above</code></td>
<td>
<p>A single positive number denoting the
minimum height above ground at which crown IDs will be calculated.
</p>
<p>Note that points directly below this threshold will still be considered
during the segmentation if they are within reach of search cylinders
constructed at the <code>segment_crowns_only_above</code> height. See &quot;How the
algorithm works&quot; to learn about the search cylinders.</p>
</td></tr>
<tr valign="top"><td><code>ground_height</code></td>
<td>
<p>One of
</p>

<ul>
<li> <p><code>NULL</code>, indicating that <code>point_cloud</code> is normalized with
ground height at zero.
</p>
</li>
<li><p> A <code><a href="../../raster/html/raster.html">raster</a></code> object providing ground heights for
the area of the (not normalized) <code>point_cloud</code>.
</p>
</li>
<li><p> A list of (ideally named) arguments to the
<code><a href="../../lidR/html/grid_terrain.html">grid_terrain</a></code> function, which will be used to generate
a ground height grid from <code>point_cloud</code>. Currently not supported
with point clouds stored in <code>data.frame</code>s. The list should not
contain an argument to the &quot;las&quot; parameter of grid_terrain.
</p>
</li></ul>

<p>Points will not be segmented wherever ground heights are NA.</p>
</td></tr>
<tr valign="top"><td><code>crown_id_column_name</code></td>
<td>
<p>A character string. The column or attribute name
under which IDs for segmented bodies should be stored.</p>
</td></tr>
<tr valign="top"><td><code>centroid_convergence_distance</code></td>
<td>
<p>A single number. Distance at which it is
assumed that subsequently calculated centroids have converged to the
nearest mode. See &quot;How the algorithm works&quot; to learn about centroids and
modes in the context of the AMS3D algorithm.</p>
</td></tr>
<tr valign="top"><td><code>max_num_centroids_per_mode</code></td>
<td>
<p>A single integer. Maximum number of
centroids calculated before the search for the nearest mode is aborted. See
&quot;How the algorithm works&quot; to learn about centroids and modes in the context
of the AMS3D algorithm.</p>
</td></tr>
<tr valign="top"><td><code>dbscan_neighborhood_radius</code></td>
<td>
<p>A single number. Radius for the spherical
DBSCAN neighborhood around a mode. See &quot;How the algorithm works&quot; to learn
about neighborhoods in the context of the DBSCAN algorithm.</p>
</td></tr>
<tr valign="top"><td><code>min_num_modes_per_neighborhood</code></td>
<td>
<p>A single integer. The minimum number of
modes within a DBSCAN neighborhood at which the mode in the neighborhood's
center will be treated as a core point. See &quot;How the algorithm works&quot; to
learn about neighborhoods and core points in the context of the DBSCAN
algorithm.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Should the function show a
progress bar and other runtime information in the console?</p>
</td></tr>
<tr valign="top"><td><code>also_return_modes</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Should mode coordinates
be returned as well?</p>
</td></tr>
<tr valign="top"><td><code>also_return_centroids</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Should centroid
coordinates be returned as well? This slows down processing by a little bit
and will return a data set which requires at least ~10 times more memory
than the input point cloud.</p>
</td></tr>
<tr valign="top"><td><code>write_crown_id_also_to_file</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. When writing
the returned LAS object to disk, should the IDs of segmented bodies be
written into that file as well? See <code><a href="../../lidR/html/add_lasattribute.html">add_lasattribute</a></code>
for additional details. Will also be used for all attributes of the LAS
object(s) which are returned if <code>also_return_modes</code> and/or
<code>also_return_centroids</code> were set to <code>TRUE</code>.
</p>
<p>For <code><a href="../../lidR/html/LAScatalog-class.html">LAScatalog-class</a></code> objects, this is only used if the
result is returned as a <code><a href="../../lidR/html/LAS.html">LAS</a></code> object in memory. If the
LAScatalog is set up to write the segmented point clouds into files, the
IDs of segmented bodies will always be written to these files as well.</p>
</td></tr>
<tr valign="top"><td><code>crown_id_file_description</code></td>
<td>
<p>A character string. If
<code>write_crown_id_also_to_file</code> is set to <code>TRUE</code> this will be used
as an additional description of the IDs of segmented bodies when the LAS
object is written to disk. See the &quot;desc&quot; parameter of
<code><a href="../../lidR/html/add_lasattribute.html">add_lasattribute</a></code> for additional details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The point cloud which was passed to the function but extended with a
column/attribute holding for each point the ID of a segmented body. IDs
with the value <code>NA</code> indicate that a point was not assigned to any
body.
</p>
<p>If <code>also_return_modes</code> and/or <code>also_return_centroids</code> were set to
<code>TRUE</code>, a list with at most three named elements in the following
order:
</p>

<dl>
<dt>segmented_point_cloud</dt><dd>
<p>The segmented point cloud which would have been returned directly if
<code>also_return_modes</code> and <code>also_return_centroids</code> had been set
to <code>FALSE</code>.
</p>
</dd>
<dt>modes</dt><dd>
<p>If <code>also_return_modes</code> was set to <code>TRUE</code>, a point cloud of
the same type as the input point cloud holding the modes calculated
with the AMS3D algorithm and two additional columns/attributes. One of
these columns/attributes holds IDs of the segmented bodies that the
modes belong to and the other (named &quot;point_index&quot;) holds indices to
the points in the input point cloud.
</p>
</dd>
<dt>centroids</dt><dd>
<p>If <code>also_return_centroids</code> was set to <code>TRUE</code>, a point cloud
of the same type as the input point cloud holding the centroids
calculated with the AMS3D algorithm and two additional
columns/attributes. One of these columns/attributes holds IDs of the
segmented bodies that the centroids belong to and the other (named
&quot;point_index&quot;) holds indices to the points in the input point cloud.
</p>
</dd>
</dl>

<p>The method for <code><a href="../../lidR/html/LAScatalog-class.html">LAScatalog-class</a></code> objects works just like
any other lidR function that accepts LAScatalogs, i.e. it returns either an
in-memory <code><a href="../../lidR/html/LAS.html">LAS</a></code> object or writes the processed chunks to
individual files and returns those file's names. Please refer to the
documentation of the <code><a href="../../lidR/html/LAScatalog-class.html">LAScatalog-class</a></code> for more details.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>data.frame</code>: Segments coordinates stored as three columns
in a <code><a href="../../base/html/data.frame.html">data.frame</a></code> or
<code><a href="../../data.table/html/data.table.html">data.table</a></code>.
</p>
</li>
<li> <p><code>LAS</code>: Segments the point cloud data of a
<code><a href="../../lidR/html/LAS.html">LAS</a></code> object.
</p>
</li>
<li> <p><code>LAScatalog</code>: Segments the point cloud data of a
<code><a href="../../lidR/html/LAScatalog-class.html">LAScatalog-class</a></code> object. This method does not support
additionally returning modes and/or centroids. Instead of the verbose
parameter use the LAScatalog's progress option (see the LAScatalog
documentation -&gt; &quot;Processing options&quot; -&gt; &quot;progress&quot;).
</p>
</li></ul>


<h3>How the algorithm works</h3>

<p>The basic assumption is that tree crowns form local maxima of point density
and height within lidar point clouds. These local maxima are called
<em>modes</em>. The algorithm tries to find the nearest mode for each point. This
is done by looking at the surrounding points and moving into the direction
of the highest point density until the nearest mode is reached.
</p>
<p>The surrounding points are found with a three-dimensional search window
which is roughly shaped like a crown itself, i.e. it is a vertical cylinder
whose diameter and height are similar to those of the surrounding tree
crowns. The exact diameter and height are dependent on the cylinder's
height above ground and are controlled with the two main parameters of the
algorithm: <code>crown_diameter_to_tree_height</code> and
<code>crown_height_to_tree_height</code>.
</p>
<p>The direction of the highest point density is found by calculating the
average position of all points within the cylinder, the cylinder's so
called <em>centroid</em>. In order to move further into the direction of the
highest point density, a new cylinder is placed on the centroid and a new
centroid is calculated for that cylinder. This goes on until the cylinders
&quot;stop moving&quot;, i.e. until two subsequently calculated centroids are closer
to each other than <code>centroid_convergence_distance</code>. At this point, the
most recently calculated centroid, is taken as the original point's nearest
mode.
</p>
<p>It sometimes happens that centroids converge only after a lot of
iterations. In order to prevent situations where an excessive number of
centroids is calculated for just one point, the parameter
<code>max_num_centroids_per_mode</code> is used to abort the centroid
calculations after a certain number of them has been performed.
Nonetheless, the last centroid found before the abortion is still taken as
a good enough guess of the nearest mode's position.
</p>
<p>After the modes of the individual points have been calculated, it can be
seen that modes of the same tree crown are positioned very close to each
other, shortly below their crown's apex. These dense clusters of modes are
identified with the DBSCAN algorithm which assigns a cluster ID to every
mode. The cluster IDs are then finally connected back to the points of the
point cloud and used as crown IDs.
</p>
<p>The DBSCAN clustering is explained nicely in
<a href="https://en.wikipedia.org/wiki/DBSCAN#Preliminary">Wikipedia</a> but here
is a quick sketch of what it does: The DBSCAN algorithm classifies points
as either core points, border points, or noise and assigns core and border
points to the same cluster if they are close enough to at least one other
core point of the cluster.
</p>
<p>In order to be core points, points need to have enough neighbors. The
parameter <code>dbscan_neighborhood_radius</code> determines the radius of the
neighborhood and the parameter <code>min_num_modes_per_neighborhood</code>
determines the minimum number of points in the neighborhood (including the
to-be-classified one), which are needed for a core point.
</p>
<p>Border points are within the neighborhood of core points but don't have
enough neighbors to be core points themselves. Noise points are not within
the neighborhood of any core point and also don't have enough neighbors to
be core points.
</p>
<p>Clusters are identified by iterating over the points and classifying them
one by one. For each point the neighborhood is scanned and the point is
classified accordingly. If the point is a core or border point, the
neighboring points are classified next. As long as it is possible to
directly connect to new core or border points in this way, the same cluster
ID is assigned to each encountered point.
</p>


<h3>References</h3>

<p>Ferraz, A., S. Saatchi, C. Mallet, and V. Meyer (2016)
<em>Lidar detection of individual tree size in tropical forests</em>. Remote
Sensing of Environment 183:318–333.
<a href="https://doi.org/10.1016/j.rse.2016.05.028">https://doi.org/10.1016/j.rse.2016.05.028</a>.
</p>


<h3>Examples</h3>

<pre>
# Load a point cloud of some trees included in the lidR package
point_cloud &lt;- lidR::readLAS(system.file(
  "extdata/MixedConifer.laz", package = "lidR"
))

# Set up a plotting function for segmented point clouds
plot_segmented_point_cloud &lt;- function(point_cloud,
                                       crown_colors = NULL,
                                       size = 3) {

  # Generate random crown colors
  if (is.null(crown_colors)) {
    crown_colors &lt;- lidR::random.colors(
      n = length(unique(point_cloud@data[["crown_id"]])) - 1
    )
  }

  # Plot the segmented crown bodies
  lidR::plot(
    point_cloud,
    color = "crown_id",
    colorPalette = crown_colors,
    size = size,
    axis = TRUE
  )
}


# Segment Normalized Point Clouds ----------------------------------------

segmented_point_cloud &lt;- crownsegmentr::segment_tree_crowns(
  point_cloud,
  crown_diameter_to_tree_height = 0.25,
  crown_height_to_tree_height = 0.5
)

plot_segmented_point_cloud(segmented_point_cloud)


# Exclude Points Below any Height on the Fly ------------------------------

segmented_point_cloud &lt;- crownsegmentr::segment_tree_crowns(
  point_cloud,
  crown_diameter_to_tree_height = 0.25,
  crown_height_to_tree_height = 0.5,
  segment_crowns_only_above = 15 # exclude points below 15 m
)

plot_segmented_point_cloud(segmented_point_cloud)


# Segment Terraneous (i.e. Non-Normalized) Point Clouds -------------------

terraneous_point_cloud &lt;- lidR::readLAS(system.file(
  "extdata/Topography.laz", package = "lidR"
))

# Either pass arguments for the lidR::grid_terrain() function
segmented_point_cloud &lt;- crownsegmentr::segment_tree_crowns(
  terraneous_point_cloud,
  crown_diameter_to_tree_height = 0.5,
  crown_height_to_tree_height = 1,
  segment_crowns_only_above = 2,
  ground_height = list(algorithm = lidR::tin())
)

# Or pass a ground height raster
ground_height_grid &lt;- lidR::grid_terrain(terraneous_point_cloud,
  algorithm = lidR::tin()
)

segmented_point_cloud &lt;- crownsegmentr::segment_tree_crowns(
  terraneous_point_cloud,
  crown_diameter_to_tree_height = 0.5,
  crown_height_to_tree_height = 1,
  segment_crowns_only_above = 2,
  ground_height = ground_height_grid
)

plot_segmented_point_cloud(segmented_point_cloud)


# Account for Different Crown Shapes with Parameter Rasters ---------------

# Create a raster of crown_diameter_to_tree_height ratios with 0.25 in the
# western half and 0.75 in the eastern half
crown_diameter_to_tree_height_grid &lt;- raster::raster(
  matrix(c(0.25, 0.75), ncol = 2),
  xmn = lidR::extent(point_cloud)@xmin,
  xmx = lidR::extent(point_cloud)@xmax,
  ymn = lidR::extent(point_cloud)@ymin,
  ymx = lidR::extent(point_cloud)@ymax,
  crs = lidR::crs(point_cloud)
)

segmented_point_cloud &lt;- crownsegmentr::segment_tree_crowns(
  point_cloud,
  crown_diameter_to_tree_height = crown_diameter_to_tree_height_grid,
  crown_height_to_tree_height = 0.5
)

# Observe how adjacent crowns are undersegmented in the right half of the plot
# where the crown_diameter_to_tree_height parameter is set too high
plot_segmented_point_cloud(segmented_point_cloud)


# Additionally Return Modes and/or Centroids ------------------------------

# You can also return the modes and centroids which were calculated during the
# segmentation in order to get a more in-depth impression of what happened
# internally.
segmentation_results &lt;- crownsegmentr::segment_tree_crowns(
  point_cloud,
  crown_diameter_to_tree_height = 0.25,
  crown_height_to_tree_height = 0.5,
  also_return_modes = TRUE,
  also_return_centroids = TRUE
)

# Generate crown colors "manually" so that we can use the same colors for
# points, modes, and centroids.
crown_colors &lt;- lidR::random.colors(
  n = length(unique(
    segmentation_results$segmented_point_cloud@data[["crown_id"]]
  )) - 1
)

# Plot the segemented point cloud
plot_segmented_point_cloud(segmentation_results$segmented_point_cloud,
  crown_colors
)
# Plot the modes
plot_segmented_point_cloud(segmentation_results$modes,
  crown_colors
)
# Plot the centroids
plot_segmented_point_cloud(segmentation_results$centroids,
  crown_colors,
  size = 1
)


# Parameter Tweaking ------------------------------------------------------

# Observe how processing gets faster while segmentation accuracy slightly
# decreases when using a larger centroid convergence distance and a larger
# DBSCAN neighborhood.
system.time(
  segmented_point_cloud &lt;- crownsegmentr::segment_tree_crowns(
    point_cloud,
    crown_diameter_to_tree_height = 0.25,
    crown_height_to_tree_height = 0.5,
    centroid_convergence_distance = 0.02,
    dbscan_neighborhood_radius = 0.5
  )
)
lidR::plot(
  segmented_point_cloud,
  color = "crown_id",
  colorPalette = lidR::random.colors(
    n = length(unique(segmented_point_cloud@data$crown_id)) - 1
  ),
  size = 3,
  axis = TRUE
)

system.time(
  segmented_point_cloud &lt;- crownsegmentr::segment_tree_crowns(
    point_cloud,
    crown_diameter_to_tree_height = 0.25,
    crown_height_to_tree_height = 0.5,
    centroid_convergence_distance = 0.01, # default value
    dbscan_neighborhood_radius = 0.3 # default value
  )
)
lidR::plot(
  segmented_point_cloud,
  color = "crown_id",
  colorPalette = lidR::random.colors(
    n = length(unique(segmented_point_cloud@data$crown_id)) - 1
  ),
  size = 3,
  axis = TRUE
)
</pre>

<hr /><div style="text-align: center;">[Package <em>crownsegmentr</em> version 0.4.4 <a href="00Index.html">Index</a>]</div>
</body></html>
